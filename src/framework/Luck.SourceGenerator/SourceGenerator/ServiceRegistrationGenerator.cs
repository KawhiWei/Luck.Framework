using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.DependencyInjection;

namespace Luck.SourceGenerator.SourceGenerator;

[Generator]
public class ServiceRegistrationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        System.Diagnostics.Debugger.Launch();
#endif

        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

    static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                    continue;

                INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                string fullName = attributeContainingTypeSymbol.ToDisplayString();

                if (fullName == "Luck.TestBase.SourceGenerators.BusinessServiceKeyAttribute")
                    return classDeclarationSyntax;
            }
        }

        return null;
    }

    static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        var distinctClasses = classes.Where(x => x is not null).Distinct();
        var serviceInfos = new List<ServiceInfo>();

        foreach (var classDeclaration in distinctClasses)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration!.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration!) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            var attributes = classSymbol.GetAttributes()
                .Where(a => a.AttributeClass?.ToDisplayString() ==
                            "Luck.TestBase.SourceGenerators.BusinessServiceKeyAttribute");

            foreach (var attribute in attributes)
            {
                var serviceType = GetServiceType(attribute);
                var serviceKey = GetServiceKey(attribute);
                var lifetime = GetLifetime(attribute);

                serviceInfos.Add(new ServiceInfo(
                    classSymbol.ToDisplayString(),
                    serviceType,
                    serviceKey,
                    lifetime));
            }
        }

        if (serviceInfos.Count > 0)
        {
            var source = GenerateExtensionMethod(serviceInfos);
            context.AddSource("ServiceCollectionExtensions.g.cs", source);
        }
    }

    static string GetServiceType(AttributeData attribute)
    {
        if (attribute.ConstructorArguments.Length > 0)
        {
            var serviceTypeValue = attribute.ConstructorArguments[0].Value;
            if (serviceTypeValue is INamedTypeSymbol serviceType)
                return serviceType.ToDisplayString();
        }

        return string.Empty;
    }

    static string GetServiceKey(AttributeData attribute)
    {
        if (attribute.ConstructorArguments.Length > 1)
        {
            var serviceKeyValue = attribute.ConstructorArguments[1].Value;
            return serviceKeyValue?.ToString() ?? string.Empty;
        }

        return string.Empty;
    }

    static ServiceLifetime GetLifetime(AttributeData attribute)
    {
        if (attribute.ConstructorArguments.Length > 2)
        {
            var lifetimeValue = attribute.ConstructorArguments[2].Value;
            if (lifetimeValue is int enumValue)
                return (ServiceLifetime)enumValue;
        }

        return ServiceLifetime.Scoped;
    }

    static string GenerateExtensionMethod(List<ServiceInfo> serviceInfos)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("namespace Luck.TestBase.SourceGenerators;");
        sb.AppendLine();
        sb.AppendLine("public static class ServiceCollectionExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    public static IServiceCollection AddBusinessServices(this IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var service in serviceInfos)
        {
            sb.AppendLine(
                $"        services.Add(new ServiceDescriptor(typeof({service.ServiceType}), \"{service.ServiceKey}\", typeof({service.ImplementationType}), ServiceLifetime.{service.Lifetime}));");
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    record ServiceInfo(string ImplementationType, string ServiceType, string ServiceKey, ServiceLifetime Lifetime);
}